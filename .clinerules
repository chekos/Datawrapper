# Datawrapper Python Library

This is a Python library for interacting with the Datawrapper API to create and manage charts.

## Project Structure

- `datawrapper/` - Main package directory
  - `__main__.py` - Main Datawrapper API client
  - `charts/` - Chart-specific implementations
    - `base.py` - BaseChart class with common functionality
    - `models.py` - Pydantic models for API metadata structures
    - `serializers.py` - Utility classes for serialization/deserialization (ColorCategory, CustomRange, CustomTicks, ModelListSerializer)
    - `annos.py` - Annotation models (TextAnnotation, RangeAnnotation)
    - Individual chart type files: `area.py`, `bar.py`, `column.py`, `line.py`, `multiple_column.py`, `scatter.py`, `stacked_bar.py`, `arrow.py`
- `tests/` - Test suite
  - `unit/` - Unit tests
  - `integration/` - Integration tests
  - `functional/` - Functional tests (require API token)
  - `samples/` - Sample chart JSON files for testing

## Key Patterns

### Serialization/Deserialization

The library uses a consistent pattern for converting between Python objects and Datawrapper API JSON:

1. **Serialization** (Python → API): Chart classes have a `serialize()` method that converts Python objects to the API's expected JSON format
2. **Deserialization** (API → Python): Chart classes have a `deserialize_model()` classmethod that converts API JSON responses back to Python objects

### Pydantic Defaults Pattern

All chart classes follow a consistent pattern for deserialization that leverages Pydantic's built-in default handling:

**Pattern:**
```python
# Only include fields in init_data if they exist in the API response
if "field-name" in visualize:
    init_data["field_name"] = visualize["field-name"]
# Pydantic applies Field defaults if not present
```

**Benefits:**
- Defaults defined once in Field definitions (not duplicated in deserialization)
- Easier maintenance - changing a default only requires updating the Field definition
- More Pydantic-idiomatic - leverages Pydantic's built-in default handling
- Clearer code - deserialization logic focuses on parsing, not default management

**Applied to all chart types:**
- LineChart, AreaChart, ColumnChart, BarChart (fully refactored)
- MultipleColumnChart, ScatterPlot, StackedBarChart, ArrowChart (fully refactored)

### Custom Ticks Utility

The `CustomTicks` class in `models.py` provides utilities for handling custom tick marks on chart axes:

- `CustomTicks.serialize(ticks: list[Any]) -> str`: Converts a list of tick values to a comma-separated string for the API
- `CustomTicks.deserialize(ticks_str: str) -> list[Any]`: Parses a comma-separated string from the API back to a list of tick values
  - Automatically converts numeric strings to numbers (int or float)
  - Preserves non-numeric strings as-is (e.g., date strings like "2020-01-01")

This utility is used by AreaChart, ColumnChart, LineChart, and MultipleColumnChart to handle the `custom-ticks-x` and `custom-ticks-y` fields.

### Custom Range Utility

The `CustomRange` class in `models.py` provides utilities for handling custom axis ranges:

- `CustomRange.serialize(range_values: list[Any] | tuple[Any, Any]) -> list[Any]`: Converts a list or tuple of range values to a list for the API
  - Accepts both lists and tuples (e.g., `[0, 100]` or `(0, 100)`)
  - Preserves the original data types of the values
- `CustomRange.deserialize(range_list: list[Any] | None) -> list[Any] | None`: Parses a list from the API back to a list of range values
  - Automatically converts numeric strings to numbers (int or float)
  - Preserves non-numeric strings as-is (e.g., date strings like "2020-01-01")
  - Returns None if input is None or empty list
  - Handles lists with 1, 2, or more values (though typically ranges have 2 values: min and max)

This utility is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ArrowChart to handle the `custom-range-x` and `custom-range-y` fields in the visualize metadata.

### Number Divisor

The `NumberDivisor` enum in `models.py` provides a developer-friendly way to specify number formatting divisors:

**Enum Values:**
- `NumberDivisor.NO_CHANGE` = "0" - No change to the number
- `NumberDivisor.AUTO_DETECT` = "auto" - Automatically detect appropriate divisor
- `NumberDivisor.DIVIDE_BY_THOUSAND` = "3" - Divide by 1,000
- `NumberDivisor.DIVIDE_BY_MILLION` = "6" - Divide by 1,000,000
- `NumberDivisor.DIVIDE_BY_BILLION` = "9" - Divide by 1,000,000,000
- `NumberDivisor.MULTIPLY_BY_HUNDRED` = "-2" - Multiply by 100 (for percentages)
- `NumberDivisor.MULTIPLY_BY_THOUSAND` = "-3" - Multiply by 1,000
- `NumberDivisor.MULTIPLY_BY_MILLION` = "-6" - Multiply by 1,000,000
- `NumberDivisor.MULTIPLY_BY_BILLION` = "-9" - Multiply by 1,000,000,000
- `NumberDivisor.MULTIPLY_BY_TRILLION` = "-12" - Multiply by 1,000,000,000,000

**Usage in ColumnFormat:**
The `ColumnFormat` model has a `number_divisor` field that accepts:
- Enum values: `NumberDivisor.DIVIDE_BY_MILLION`
- Raw integers: `6`, `-2`, `0`
- Raw strings: `"6"`, `"auto"`, `"0"`

The field has validation to ensure only valid values are accepted. Invalid values raise a `ValidationError`.

**Serialization:**
- When serializing to API format via `ColumnFormatList.serialize_to_dict()`, the default value (0 or "0") is excluded from the output
- Enum values are serialized as their string values (e.g., `NumberDivisor.DIVIDE_BY_MILLION` becomes `"6"`)
- The API field name is `"number-divisor"` (with hyphen)

**Example:**
```python
from datawrapper.charts.models import ColumnFormat, NumberDivisor

# Using enum (recommended for clarity)
col_format = ColumnFormat(
    column="revenue",
    number_divisor=NumberDivisor.DIVIDE_BY_MILLION,
    number_prepend="$",
    number_append="M"
)

# Using raw int (also valid)
col_format = ColumnFormat(column="revenue", number_divisor=6)

# Using raw string (also valid)
col_format = ColumnFormat(column="revenue", number_divisor="auto")
```

### Line Width and Dash Enums

The `LineWidth` and `LineDash` enums in `models.py` provide developer-friendly ways to specify line styling in LineChart configurations:

**LineWidth Enum Values:**
- `LineWidth.THIN` = "1" - Thin line (1px)
- `LineWidth.MEDIUM` = "2" - Medium line (2px)
- `LineWidth.THICK` = "3" - Thick line (3px)
- `LineWidth.EXTRA_THICK` = "4" - Extra thick line (4px)

**LineDash Enum Values:**
- `LineDash.SOLID` = None - Solid line (no dashes)
- `LineDash.DASHED` = "4,2" - Dashed line pattern
- `LineDash.DOTTED` = "1,2" - Dotted line pattern
- `LineDash.DASH_DOT` = "8,2,1,2" - Dash-dot pattern
- `LineDash.LONG_DASH` = "8,4" - Long dash pattern

**Usage in Line Model:**
The `Line` model (used in LineChart) has `width` and `dash` fields that accept:
- Enum values: `LineWidth.THICK`, `LineDash.DASHED`
- Raw strings: `"3"`, `"4,2"`, `None`

Both fields have validation to ensure only valid values are accepted. Invalid values raise a `ValidationError`.

**Serialization:**
- Enum values are serialized as their string values (e.g., `LineWidth.THICK` becomes `"3"`)
- `LineDash.SOLID` (None) is serialized as `None`
- The API field names are `"width"` and `"dash"`

**Example:**
```python
from datawrapper.charts.models import Line, LineWidth, LineDash

# Using enums (recommended for clarity)
line = Line(
    column="temperature",
    width=LineWidth.THICK,
    dash=LineDash.DASHED,
    color="#FF0000"
)

# Using raw strings (also valid)
line = Line(column="temperature", width="3", dash="4,2")

# Solid line (no dashes)
line = Line(column="temperature", width=LineWidth.MEDIUM, dash=LineDash.SOLID)
```

### Color Category Utility

The `ColorCategory` class in `serializers.py` provides utilities for handling color category mappings:

- `ColorCategory.serialize(color_map, category_labels=None, category_order=None, exclude_from_key=None) -> dict`: Converts Python color mappings to the API's expected format with a `map` key and optional additional fields
- `ColorCategory.deserialize(color_category_obj) -> dict`: Parses the API's color category structure back to Python, returning a dictionary with keys:
  - `color_category`: The color mapping dictionary
  - `category_labels`: Optional labels for categories
  - `category_order`: Optional ordering for categories
  - `exclude_from_color_key`: Optional list of categories to exclude from the legend

This utility is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, StackedBarChart, and ArrowChart to handle the `color-category` field in the visualize metadata.

### Replace Flags Utility

The `ReplaceFlags` class in `serializers.py` provides utilities for handling the replace-flags configuration:

**API Format vs Python Format:**
- **API Format**: Nested object with `{"enabled": bool, "style": str}` (note: uses "style" not "type")
- **Python Format**: Simple string ("off", "4x3", "1x1", "circle")

**Methods:**
- `ReplaceFlags.serialize(flag_type: str) -> dict`: Converts simple string format to API nested object format
  - `"off"` → `{"enabled": False, "style": ""}`
  - `"4x3"` → `{"enabled": True, "style": "4x3"}`
- `ReplaceFlags.deserialize(api_obj: dict | None) -> str`: Converts API nested object format to simple string format
  - `{"enabled": True, "style": "4x3"}` → `"4x3"`
  - `{"enabled": False, "style": ""}` → `"off"`
  - `None` → `"off"`

**Usage:**
This utility is used by BarChart and StackedBarChart to handle the `replace-flags` field, which controls whether country codes are replaced with flag icons in the visualization.

**Important Note:**
The API uses the field name "style" (not "type") in the nested object. This is different from the initial implementation and was corrected based on actual API responses.

**Example:**
```python
from datawrapper.charts.serializers import ReplaceFlags

# Serialization (Python → API)
api_format = ReplaceFlags.serialize("4x3")
# Returns: {"enabled": True, "style": "4x3"}

# Deserialization (API → Python)
python_format = ReplaceFlags.deserialize({"enabled": True, "style": "4x3"})
# Returns: "4x3"
```

### Negative Color Utility

The `NegativeColor` class in `serializers.py` provides utilities for handling negative color configuration:

**API Format vs Python Format:**
- **API Format**: Nested object with `{"enabled": bool, "value": str}` where value is a color hex code
- **Python Format**: Simple string (color hex code like "#ff0000") or None

**Methods:**
- `NegativeColor.serialize(color: str | None) -> dict | None`: Converts simple color string to API nested object format
  - `"#ff0000"` → `{"enabled": True, "value": "#ff0000"}`
  - `None` → `None`
- `NegativeColor.deserialize(api_obj: dict | None) -> str | None`: Converts API nested object format to simple color string
  - `{"enabled": True, "value": "#ff0000"}` → `"#ff0000"`
  - `{"enabled": False, "value": ""}` → `None`
  - `None` → `None`

**Usage:**
This utility is used by ColumnChart, MultipleColumnChart, and StackedBarChart to handle the `negativeColor` field in the visualize metadata. It consolidates what were previously two separate fields (`negative_color_enabled` and `negative_color_value`) into a single, more intuitive field.

**Example:**
```python
from datawrapper.charts.serializers import NegativeColor

# Serialization (Python → API)
api_format = NegativeColor.serialize("#ff0000")
# Returns: {"enabled": True, "value": "#ff0000"}

# Deserialization (API → Python)
python_format = NegativeColor.deserialize({"enabled": True, "value": "#ff0000"})
# Returns: "#ff0000"

# When disabled
python_format = NegativeColor.deserialize({"enabled": False, "value": ""})
# Returns: None
```

### Plot Height Utility

The `PlotHeight` class in `serializers.py` provides utilities for handling chart plot height configuration:

**API Format vs Python Format:**
- **API Format**: Nested object with `{"mode": str, "fixed": int}` where mode can be "fixed" or "ratio"
- **Python Format**: Either an integer (for fixed mode) or a float (for ratio mode)

**Methods:**
- `PlotHeight.serialize(height: int | float) -> dict`: Converts simple numeric format to API nested object format
  - Integer (e.g., `400`) → `{"mode": "fixed", "fixed": 400}`
  - Float (e.g., `0.5`) → `{"mode": "ratio", "fixed": 0.5}`
- `PlotHeight.deserialize(api_obj: dict | None) -> int | float | None`: Converts API nested object format to simple numeric format
  - `{"mode": "fixed", "fixed": 400}` → `400`
  - `{"mode": "ratio", "fixed": 0.5}` → `0.5`
  - `None` → `None`

**Usage:**
This utility is used by LineChart, AreaChart, ColumnChart, MultipleColumnChart, and ScatterPlot to handle the `plot-height` field in the visualize metadata.

**Example:**
```python
from datawrapper.charts.serializers import PlotHeight

# Serialization (Python → API)
api_format = PlotHeight.serialize(400)  # Fixed height
# Returns: {"mode": "fixed", "fixed": 400}

api_format = PlotHeight.serialize(0.5)  # Ratio mode
# Returns: {"mode": "ratio", "fixed": 0.5}

# Deserialization (API → Python)
python_format = PlotHeight.deserialize({"mode": "fixed", "fixed": 400})
# Returns: 400

python_format = PlotHeight.deserialize({"mode": "ratio", "fixed": 0.5})
# Returns: 0.5
```

### Annotations

Charts support three types of annotations:
- `TextAnnotation`: Text labels at specific coordinates
- `RangeAnnotation`: Highlighted ranges with optional labels
- `AreaFill`: Filled areas between two lines (LineChart only)

All annotation classes have:
- `serialize_model()` method: Converts a single annotation instance to API format
- `deserialize_model()` classmethod: Converts API JSON (dict with UUID keys or list) back to Python list of dicts

The BaseChart class provides `_serialize_annotations()` helper method to handle lists of annotations during serialization.

Chart classes use the annotation class methods directly:
- For serialization: `self._serialize_annotations(self.text_annotations, TextAnnotation)`
- For deserialization: `TextAnnotation.deserialize_model(visualize.get("text-annotations"))`

This pattern is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ScatterPlot.

**Important API Format Notes:**
- The API returns annotations as dictionaries with UUID keys mapping to annotation data
- The API expects annotations to be sent as dictionaries with UUID keys (not lists)
- The `deserialize_model()` methods handle both dict and list formats for flexibility
- The `id` field is preserved during deserialization but not included in serialization output (used as dict key)

## Testing

- Run all tests: `uv run python -m pytest tests/`
- Run unit tests only: `uv run python -m pytest tests/unit/`
- Run integration tests: `uv run python -m pytest tests/integration/`
- Most functional tests require `DATAWRAPPER_ACCESS_TOKEN` environment variable
- Some functional tests (e.g., `test_folders.py`) use mocked API responses and don't require an API token

## Recent Changes

### Pydantic Defaults Refactoring - All Chart Types (2025-01-15)

Completed comprehensive refactoring of all chart deserialization methods to leverage Pydantic Field defaults:

**Charts Refactored:**
- LineChart, AreaChart, ColumnChart, BarChart (Session 1-2)
- MultipleColumnChart, ScatterPlot, StackedBarChart, ArrowChart (Session 3)

**Pattern Applied:**
Changed from `visualize.get("field-name", default_value)` to conditional assignment:
```python
if "field-name" in visualize:
    init_data["field_name"] = visualize["field-name"]
```

**Benefits:**
- Eliminated 100+ duplicate default value specifications across all chart types
- Defaults now defined once in Field definitions
- Easier maintenance - changing a default only requires updating the Field definition
- More Pydantic-idiomatic - leverages Pydantic's built-in default handling
- Clearer code - deserialization logic focuses on parsing, not default management
- Consistent pattern across all chart types

**Test Results:**
- All 542 unit and integration tests pass
- No breaking changes introduced
- Code is more maintainable and follows Pydantic best practices

### Replace Flags Refactoring (2025-01-15)

Created a new `ReplaceFlags` utility class in `serializers.py` to handle the complex nested structure of the `replace-flags` field:

**Changes:**
- Extracted replace-flags serialization/deserialization logic into dedicated utility class
- Corrected field name from "type" to "style" based on actual API responses
- Applied to BarChart and StackedBarChart
- Created comprehensive unit tests in `tests/unit/serializers/test_replace_flags.py`

**Pattern:**
```python
# In chart models
replace_flags: str = Field(default="off", serialization_alias="replace-flags")

@field_serializer("replace_flags")
def serialize_replace_flags(self, value: str) -> dict:
    return ReplaceFlags.serialize(value)

# In deserialization
if "replace-flags" in visualize:
    init_data["replace_flags"] = ReplaceFlags.deserialize(visualize["replace-flags"])
```

**Benefits:**
- Consistent handling across chart types
- Cleaner chart model code
- Easier to test and maintain
- Follows same pattern as PlotHeight utility

**Test Results:**
- All 573 unit and integration tests pass
- New utility properly handles all flag styles (off, 4x3, 1x1, circle)

### Mocked Folder Tests (2025-01-15)

Refactored `tests/functional/test_folders.py` to use fully mocked API responses instead of hitting the live API:

**Changes:**
- Replaced `@pytest.mark.api` decorator with `monkeypatch` fixtures
- Created mock response data for all folder operations (get, create, update, delete)
- Implemented stateful mock functions that track call counts to return appropriate responses
- Tests now run without requiring `DATAWRAPPER_ACCESS_TOKEN` environment variable

**Benefits:**
- Tests run faster without network calls
- Tests are more reliable (no dependency on API availability)
- Tests can run in CI/CD environments without API credentials
- Easier to test edge cases and error conditions

**Pattern:**
```python
def test_folder_crud(monkeypatch):
    # Define mock response data
    mock_folder = {"id": 12345, "name": "Test Folder", ...}

    # Create mock functions with self parameter
    def mock_post(self, url, **kwargs):
        return mock_folder

    # Patch the methods
    monkeypatch.setattr("datawrapper.Datawrapper.post", mock_post)

    # Run tests
    dw = Datawrapper()
    result = dw.create_folder(name="Test Folder")
    assert result["id"] == 12345
```

### Mocked Account and Chart History Tests (2025-01-15)

Refactored four tests in `tests/functional/test_me.py` to use fully mocked API responses:

**Tests Mocked:**
1. `test_get_my_account` - Mocks GET request to retrieve account information
2. `test_update_my_account` - Mocks PATCH requests to update account information
3. `test_get_my_recently_edited_charts` - Mocks GET requests with various parameters (limit, offset, min_last_edit_step)
4. `test_get_my_recently_published_charts` - Mocks GET requests with various parameters (limit, offset)

### MultipleColumnChart Negative Color Default Fix (2025-01-15)

Fixed inconsistency in `negative_color` default value for MultipleColumnChart:

**Issue:**
- MultipleColumnChart had `negative_color` default set to `"#de2d26"` (red color)
- ColumnChart and StackedBarChart both use `None` as the default
- This inconsistency meant MultipleColumnChart would always show negative values in red by default, while other chart types required explicit configuration

**Fix:**
- Changed MultipleColumnChart `negative_color` default from `"#de2d26"` to `None`
- Now consistent with ColumnChart and StackedBarChart behavior
- Users must explicitly set a color if they want negative values highlighted

**Test Results:**
- All 634 tests pass
- No tests were affected by this change (no tests relied on the specific default value)

### Mocked User Tests (2025-01-15)

Refactored `test_get_user` in `tests/functional/test_users.py` to use fully mocked API responses:

**Test Mocked:**
- `test_get_user` - Mocks multiple sequential GET requests:
  1. `get_users()` - Returns list of users
  2. `get_my_account()` - Returns current user account
  3. `get_user(user_id)` - Returns specific user details
  4. `get_recently_edited_charts(user_id)` - Returns user's edited charts
  5. `get_recently_published_charts(user_id)` - Returns user's published charts

**Changes:**
- Removed `@pytest.mark.api` decorators from all four tests
- Added `monkeypatch` parameter to function signatures
- Created mock response data for all test scenarios
- Implemented stateful mock functions that track call counts and return appropriate responses
- Tests now run without requiring `DATAWRAPPER_ACCESS_TOKEN` environment variable

**Changes for test_get_user:**
- Removed `@pytest.mark.api` decorator
- Added `monkeypatch` parameter to function signature
- Created comprehensive mock response data for all five API calls
- Implemented stateful mock GET function that tracks call count and returns appropriate responses based on sequence
- Test now runs without requiring `DATAWRAPPER_ACCESS_TOKEN` environment variable

**Benefits:**
- Tests run faster without network calls
- Tests are more reliable (no dependency on API availability)
- Tests can run in CI/CD environments without API credentials
- Follows same pattern as mocked folder tests

**Pattern for GET requests:**
```python
def test_get_my_account(monkeypatch):
    # Define mock response data
    mock_account = {"id": 12345, "email": "test@example.com", ...}

    def mock_get(self, url, **kwargs):
        return mock_account

    monkeypatch.setattr("datawrapper.Datawrapper.get", mock_get)

    # Run tests
    dw = Datawrapper()
    result = dw.get_my_account()
    assert result["id"] == 12345
```

**Pattern for PATCH requests:**
```python
def test_update_my_account(monkeypatch):
    # Define mock response data for different calls
    mock_account_foobar = {"id": 12345, "name": "Foobar", ...}
    mock_account_test_user = {"id": 12345, "name": "Test user", ...}

    # Track which call we're on
    call_count = [0]

    def mock_patch(self, url, **kwargs):
        call_count[0] += 1
        if call_count[0] == 1:
            return mock_account_foobar
        else:
            return mock_account_test_user

    monkeypatch.setattr("datawrapper.Datawrapper.patch", mock_patch)

    # Run tests
    dw = Datawrapper()
    result1 = dw.update_my_account(name="Foobar")
    assert result1["name"] == "Foobar"
```
