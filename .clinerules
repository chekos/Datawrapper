# Datawrapper Python Library

This is a Python library for interacting with the Datawrapper API to create and manage charts.

## Project Structure

- `datawrapper/` - Main package directory
  - `__main__.py` - Main Datawrapper API client
  - `charts/` - Chart-specific implementations
    - `base.py` - BaseChart class with common functionality
    - `models.py` - Pydantic models for API metadata structures
    - `annos.py` - Annotation models (TextAnnotation, RangeAnnotation)
    - Individual chart type files: `area.py`, `bar.py`, `column.py`, `line.py`, `multiple_column.py`, `scatter.py`, `stacked_bar.py`, `arrow.py`
- `tests/` - Test suite
  - `unit/` - Unit tests
  - `integration/` - Integration tests
  - `functional/` - Functional tests (require API token)
  - `samples/` - Sample chart JSON files for testing

## Key Patterns

### Serialization/Deserialization

The library uses a consistent pattern for converting between Python objects and Datawrapper API JSON:

1. **Serialization** (Python → API): Chart classes have a `serialize()` method that converts Python objects to the API's expected JSON format
2. **Deserialization** (API → Python): Chart classes have a `deserialize_model()` classmethod that converts API JSON responses back to Python objects

### Custom Ticks Utility

The `CustomTicks` class in `models.py` provides utilities for handling custom tick marks on chart axes:

- `CustomTicks.serialize(ticks: list[Any]) -> str`: Converts a list of tick values to a comma-separated string for the API
- `CustomTicks.deserialize(ticks_str: str) -> list[Any]`: Parses a comma-separated string from the API back to a list of tick values
  - Automatically converts numeric strings to numbers (int or float)
  - Preserves non-numeric strings as-is (e.g., date strings like "2020-01-01")

This utility is used by AreaChart, ColumnChart, LineChart, and MultipleColumnChart to handle the `custom-ticks-x` and `custom-ticks-y` fields.

### Custom Range Utility

The `CustomRange` class in `models.py` provides utilities for handling custom axis ranges:

- `CustomRange.serialize(range_values: list[Any] | tuple[Any, Any]) -> list[Any]`: Converts a list or tuple of range values to a list for the API
  - Accepts both lists and tuples (e.g., `[0, 100]` or `(0, 100)`)
  - Preserves the original data types of the values
- `CustomRange.deserialize(range_list: list[Any] | None) -> list[Any] | None`: Parses a list from the API back to a list of range values
  - Automatically converts numeric strings to numbers (int or float)
  - Preserves non-numeric strings as-is (e.g., date strings like "2020-01-01")
  - Returns None if input is None or empty list
  - Handles lists with 1, 2, or more values (though typically ranges have 2 values: min and max)

This utility is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ArrowChart to handle the `custom-range-x` and `custom-range-y` fields in the visualize metadata.

### Number Divisor

The `NumberDivisor` enum in `models.py` provides a developer-friendly way to specify number formatting divisors:

**Enum Values:**
- `NumberDivisor.NO_CHANGE` = "0" - No change to the number
- `NumberDivisor.AUTO_DETECT` = "auto" - Automatically detect appropriate divisor
- `NumberDivisor.DIVIDE_BY_THOUSAND` = "3" - Divide by 1,000
- `NumberDivisor.DIVIDE_BY_MILLION` = "6" - Divide by 1,000,000
- `NumberDivisor.DIVIDE_BY_BILLION` = "9" - Divide by 1,000,000,000
- `NumberDivisor.MULTIPLY_BY_HUNDRED` = "-2" - Multiply by 100 (for percentages)
- `NumberDivisor.MULTIPLY_BY_THOUSAND` = "-3" - Multiply by 1,000
- `NumberDivisor.MULTIPLY_BY_MILLION` = "-6" - Multiply by 1,000,000
- `NumberDivisor.MULTIPLY_BY_BILLION` = "-9" - Multiply by 1,000,000,000
- `NumberDivisor.MULTIPLY_BY_TRILLION` = "-12" - Multiply by 1,000,000,000,000

**Usage in ColumnFormat:**
The `ColumnFormat` model has a `number_divisor` field that accepts:
- Enum values: `NumberDivisor.DIVIDE_BY_MILLION`
- Raw integers: `6`, `-2`, `0`
- Raw strings: `"6"`, `"auto"`, `"0"`

The field has validation to ensure only valid values are accepted. Invalid values raise a `ValidationError`.

**Serialization:**
- When serializing to API format via `ColumnFormatList.serialize_to_dict()`, the default value (0 or "0") is excluded from the output
- Enum values are serialized as their string values (e.g., `NumberDivisor.DIVIDE_BY_MILLION` becomes `"6"`)
- The API field name is `"number-divisor"` (with hyphen)

**Example:**
```python
from datawrapper.charts.models import ColumnFormat, NumberDivisor

# Using enum (recommended for clarity)
col_format = ColumnFormat(
    column="revenue",
    number_divisor=NumberDivisor.DIVIDE_BY_MILLION,
    number_prepend="$",
    number_append="M"
)

# Using raw int (also valid)
col_format = ColumnFormat(column="revenue", number_divisor=6)

# Using raw string (also valid)
col_format = ColumnFormat(column="revenue", number_divisor="auto")
```

### Color Category Utility

The `ColorCategory` class in `models.py` provides utilities for handling color category mappings:

- `ColorCategory.serialize(color_map, category_labels=None, category_order=None, exclude_from_key=None) -> dict`: Converts Python color mappings to the API's expected format with a `map` key and optional additional fields
- `ColorCategory.deserialize(color_category_obj) -> dict`: Parses the API's color category structure back to Python, returning a dictionary with keys:
  - `color_category`: The color mapping dictionary
  - `category_labels`: Optional labels for categories
  - `category_order`: Optional ordering for categories
  - `exclude_from_color_key`: Optional list of categories to exclude from the legend

This utility is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, StackedBarChart, and ArrowChart to handle the `color-category` field in the visualize metadata.

### Annotations

Charts support three types of annotations:
- `TextAnnotation`: Text labels at specific coordinates
- `RangeAnnotation`: Highlighted ranges with optional labels
- `AreaFill`: Filled areas between two lines (LineChart only)

All annotation classes have:
- `serialize_model()` method: Converts a single annotation instance to API format
- `deserialize_model()` classmethod: Converts API JSON (dict with UUID keys or list) back to Python list of dicts

The BaseChart class provides `_serialize_annotations()` helper method to handle lists of annotations during serialization.

Chart classes use the annotation class methods directly:
- For serialization: `self._serialize_annotations(self.text_annotations, TextAnnotation)`
- For deserialization: `TextAnnotation.deserialize_model(visualize.get("text-annotations"))`

This pattern is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ScatterPlot.

**Important API Format Notes:**
- The API returns annotations as dictionaries with UUID keys mapping to annotation data
- The API expects annotations to be sent as dictionaries with UUID keys (not lists)
- The `deserialize_model()` methods handle both dict and list formats for flexibility
- The `id` field is preserved during deserialization but not included in serialization output (used as dict key)

## Testing

- Run all tests: `uv run python -m pytest tests/`
- Run unit tests only: `uv run python -m pytest tests/unit/`
- Run integration tests: `uv run python -m pytest tests/integration/`
- Functional tests require `DATAWRAPPER_ACCESS_TOKEN` environment variable

## Recent Changes

### Area Fill Serialization Fix (2025-01-13)

Fixed the area fill serialization in LineChart to match the Datawrapper API's expected format:

- Updated `AreaFill.serialize_model()` in `annos.py` to return a list of area fill dictionaries instead of a dictionary with UUID keys
- The API expects area fills in the format: `[{fill1}, {fill2}, ...]` (same as text/range annotations)
- Updated `tests/integration/test_line_chart.py` to verify the correct list format
- All 220 integration tests pass

**Important**: Area fills follow the same serialization pattern as text and range annotations - they serialize to a list for POST/PUT requests, even though the API returns them as a dict with UUID keys in GET responses.

### Annotation Serialization Fix (2025-01-13)

Fixed the annotation serialization to match the Datawrapper API's expected format:

- Updated `BaseChart._serialize_annotations()` to return a list of annotation dictionaries instead of a dictionary
- The API expects annotations in the format: `[{annotation1}, {annotation2}, ...]`
- Updated integration tests to verify the correct list format
- All 232 unit tests and 220 integration tests pass

### Export Test Mocking (2025-01-13)

Converted the export integration tests to use mocking instead of hitting the API:

- Updated `tests/integration/test_base_export.py` to mock the Datawrapper client
- Tests now run faster and are more reliable (no network dependencies)
- Removed the `DATAWRAPPER_ACCESS_TOKEN` requirement for these tests
- Tests verify that the export method correctly delegates to the client's `export_chart()` method

### BaseChart Publish Method (2025-01-13)

Added a `publish()` method to the BaseChart class that delegates to the main Datawrapper client's `publish_chart()` method:

- The `publish()` method is available on all chart instances (AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, ScatterPlot, StackedBarChart, ArrowChart)
- Requires that the chart has been created (has a `chart_id`)
- Automatically gets or creates a Datawrapper client using the chart's access token
- Returns the API response from publishing the chart
- All 232 unit tests and 220 integration tests pass

Usage example:
```python
chart = BarChart(title="My Chart", data=data)
chart.create()  # Creates the chart and sets chart_id
response = chart.publish()  # Publishes the chart
```

### Annotation Serialization Refactoring (2025-01-14)

Refactored annotation serialization to use a new `ModelListSerializer` utility class:

- Created `ModelListSerializer` class in `models.py` with a `serialize()` static method
- This utility handles serializing lists of Pydantic model instances (like annotations) to API format
- Removed the `_serialize_annotations()` helper method from BaseChart
- Updated AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ScatterPlot to use `ModelListSerializer.serialize()`
- Added comprehensive unit tests in `tests/unit/models/test_model_list_serializer.py`
- All 457 unit and integration tests pass

The `ModelListSerializer` provides a centralized, reusable way to serialize lists of model instances:
- Handles both model instances and dict inputs
- Validates and converts items using the model class's `serialize_model()` method
- Returns a list of serialized dictionaries ready for the API

This pattern can be reused for any future model list serialization needs beyond just annotations.

### Annotation Deserialization Refactoring (2025-01-13)

Simplified annotation deserialization by adding `deserialize_model()` classmethods to annotation classes:

- Added `TextAnnotation.deserialize_model()` and `RangeAnnotation.deserialize_model()` classmethods in `annos.py`
- These methods handle converting API JSON (list of annotation dicts or None) to Python list of dicts
- Updated AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ScatterPlot to call annotation class methods directly

This change creates symmetry between serialization and deserialization:
- Serialization: Chart calls `ModelListSerializer.serialize(annotations, AnnotationClass)`
- Deserialization: Chart calls `AnnotationClass.deserialize_model(api_data)`

The annotation classes now fully own their own serialization/deserialization logic.

### Color Category Refactoring (2025-01-13)

Refactored the color category handling to eliminate code duplication:

- Created `ColorCategory` utility class in `models.py` with `serialize()` and `deserialize()` static methods
- Updated AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, StackedBarChart, and ArrowChart to use the new utility
- Removed duplicate color category serialization/deserialization logic from individual chart classes
- Added comprehensive unit tests in `tests/unit/models/test_color_category.py`
- All 220 existing integration tests continue to pass

The `ColorCategory` utility handles both simple color mappings and complex structures with category labels, ordering, and exclusions from the legend.

### Custom Ticks Refactoring (2025-01-13)

Refactored the custom tick marks handling to eliminate code duplication:

- Created `CustomTicks` utility class in `models.py` with `serialize()` and `deserialize()` static methods
- Updated AreaChart, ColumnChart, LineChart, and MultipleColumnChart to use the new utility
- Removed duplicate tick parsing logic from individual chart classes
- Added comprehensive unit tests in `tests/unit/models/test_custom_ticks.py`
- All existing integration tests continue to pass

The `CustomTicks.deserialize()` method intelligently handles mixed data types:
- Converts numeric strings to int or float
- Preserves non-numeric strings (like dates) as-is
- Handles empty strings and whitespace

### Transform Model Refactoring (2025-01-13)

Refactored the Transform model to use direct dictionary access instead of deprecated `from_api_data_section()` method:

- Updated `Transform.model_validate()` to directly access the `data` section from API responses
- Removed dependency on the deprecated `from_api_data_section()` method
- The Transform model now uses standard Pydantic validation with dictionary access
- All 231 unit tests and 220 integration tests continue to pass

This change aligns with the library's pattern of using direct dictionary access for API response parsing rather than custom helper methods.

### Line Configuration Refactoring (2025-01-14)

Refactored the Line configuration handling in LineChart to use dedicated serialization/deserialization methods:

- Added `Line.serialize_model()` static method to convert Line instances to API format
- Added `Line.deserialize_model()` classmethod to parse API line configurations back to Python
- Updated `LineChart.serialize_model()` to use `Line.serialize_model()` for each line configuration
- Updated `LineChart.deserialize_model()` to use `Line.deserialize_model()` for parsing line configurations
- All 457 unit and integration tests pass

This change creates consistency with other model patterns in the library:
- Line configurations now own their own serialization/deserialization logic
- Eliminates inline serialization/deserialization code in LineChart
- Makes the code more maintainable and easier to test

### RangeAnnotation Permissive Position Fields (2025-01-14)

Made the RangeAnnotation position fields (x0, x1, y0, y1) optional to support different annotation types:

- Changed all position fields from required to optional (default None) in the RangeAnnotation model
- Updated `serialize_model()` to only include non-None position values in the output
- Updated `deserialize_model()` to handle missing position values from API responses
- Added comprehensive tests in `tests/unit/models/test_range_annotation_permissive.py` covering:
  - Vertical lines (only x0 needed)
  - Vertical ranges (x0 and x1 needed)
  - Horizontal lines (only y0 needed)
  - Horizontal ranges (y0 and y1 needed)
  - Mixed numeric and string positions
  - API format with duplicate positions
- All 487 unit and integration tests pass

This change allows RangeAnnotation to support:
- **Vertical lines**: Set only `x0` with `type="x"` and `display="line"`
- **Vertical ranges**: Set `x0` and `x1` with `type="x"` and `display="range"`
- **Horizontal lines**: Set only `y0` with `type="y"` and `display="line"`
- **Horizontal ranges**: Set `y0` and `y1` with `type="y"` and `display="range"`

The serialization now only includes the position fields that are actually set, making the API payloads cleaner and more flexible.
