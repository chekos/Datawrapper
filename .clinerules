# Datawrapper Python Library

This is a Python library for interacting with the Datawrapper API to create and manage charts.

## Project Structure

- `datawrapper/` - Main package directory
  - `__main__.py` - Main Datawrapper API client
  - `charts/` - Chart-specific implementations
    - `base.py` - BaseChart class with common functionality
    - `models.py` - Pydantic models for API metadata structures
    - `serializers.py` - Utility classes for serialization/deserialization (ColorCategory, CustomRange, CustomTicks, ModelListSerializer, ValueLabels)
    - `annos.py` - Annotation models (TextAnnotation, RangeAnnotation)
    - Individual chart type files: `area.py`, `bar.py`, `column.py`, `line.py`, `multiple_column.py`, `scatter.py`, `stacked_bar.py`, `arrow.py`
- `tests/` - Test suite
  - `unit/` - Unit tests
  - `integration/` - Integration tests
  - `functional/` - Functional tests (require API token)
  - `samples/` - Sample chart JSON files for testing

## Key Patterns

### Serialization/Deserialization

The library uses a consistent pattern for converting between Python objects and Datawrapper API JSON:

1. **Serialization** (Python → API): Chart classes have a `serialize()` method that converts Python objects to the API's expected JSON format
2. **Deserialization** (API → Python): Chart classes have a `deserialize_model()` classmethod that converts API JSON responses back to Python objects

### Pydantic Defaults Pattern

All chart classes follow a consistent pattern for deserialization that leverages Pydantic's built-in default handling:

**Pattern:**
```python
# Only include fields in init_data if they exist in the API response
if "field-name" in visualize:
    init_data["field_name"] = visualize["field-name"]
# Pydantic applies Field defaults if not present
```

**Benefits:**
- Defaults defined once in Field definitions (not duplicated in deserialization)
- Easier maintenance - changing a default only requires updating the Field definition
- More Pydantic-idiomatic - leverages Pydantic's built-in default handling
- Clearer code - deserialization logic focuses on parsing, not default management

**Applied to all chart types:**
- LineChart, AreaChart, ColumnChart, BarChart (fully refactored)
- MultipleColumnChart, ScatterPlot, StackedBarChart, ArrowChart (fully refactored)

### Custom Ticks Utility

The `CustomTicks` class in `models.py` provides utilities for handling custom tick marks on chart axes:

- `CustomTicks.serialize(ticks: list[Any]) -> str`: Converts a list of tick values to a comma-separated string for the API
- `CustomTicks.deserialize(ticks_str: str) -> list[Any]`: Parses a comma-separated string from the API back to a list of tick values
  - Automatically converts numeric strings to numbers (int or float)
  - Preserves non-numeric strings as-is (e.g., date strings like "2020-01-01")

This utility is used by AreaChart, ColumnChart, LineChart, and MultipleColumnChart to handle the `custom-ticks-x` and `custom-ticks-y` fields.

### Custom Range Utility

The `CustomRange` class in `models.py` provides utilities for handling custom axis ranges:

- `CustomRange.serialize(range_values: list[Any] | tuple[Any, Any]) -> list[Any]`: Converts a list or tuple of range values to a list for the API
  - Accepts both lists and tuples (e.g., `[0, 100]` or `(0, 100)`)
  - Preserves the original data types of the values
- `CustomRange.deserialize(range_list: list[Any] | None) -> list[Any] | None`: Parses a list from the API back to a list of range values
  - Automatically converts numeric strings to numbers (int or float)
  - Preserves non-numeric strings as-is (e.g., date strings like "2020-01-01")
  - Returns None if input is None or empty list
  - Handles lists with 1, 2, or more values (though typically ranges have 2 values: min and max)

This utility is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, and ArrowChart to handle the `custom-range-x` and `custom-range-y` fields in the visualize metadata.

### Number Divisor

The `NumberDivisor` enum in `models.py` provides a developer-friendly way to specify number formatting divisors:

**Enum Values:**
- `NumberDivisor.NO_CHANGE` = "0" - No change to the number
- `NumberDivisor.AUTO_DETECT` = "auto" - Automatically detect appropriate divisor
- `NumberDivisor.DIVIDE_BY_THOUSAND` = "3" - Divide by 1,000
- `NumberDivisor.DIVIDE_BY_MILLION` = "6" - Divide by 1,000,000
- `NumberDivisor.DIVIDE_BY_BILLION` = "9" - Divide by 1,000,000,000
- `NumberDivisor.MULTIPLY_BY_HUNDRED` = "-2" - Multiply by 100 (for percentages)
- `NumberDivisor.MULTIPLY_BY_THOUSAND` = "-3" - Multiply by 1,000
- `NumberDivisor.MULTIPLY_BY_MILLION` = "-6" - Multiply by 1,000,000
- `NumberDivisor.MULTIPLY_BY_BILLION` = "-9" - Multiply by 1,000,000,000
- `NumberDivisor.MULTIPLY_BY_TRILLION` = "-12" - Multiply by 1,000,000,000,000

**Usage in ColumnFormat:**
The `ColumnFormat` model has a `number_divisor` field that accepts:
- Enum values: `NumberDivisor.DIVIDE_BY_MILLION`
- Raw integers: `6`, `-2`, `0`
- Raw strings: `"6"`, `"auto"`, `"0"`

The field has validation to ensure only valid values are accepted. Invalid values raise a `ValidationError`.

**Serialization:**
- When serializing to API format via `ColumnFormatList.serialize_to_dict()`, the default value (0 or "0") is excluded from the output
- Enum values are serialized as their string values (e.g., `NumberDivisor.DIVIDE_BY_MILLION` becomes `"6"`)
- The API field name is `"number-divisor"` (with hyphen)

**Example:**
```python
from datawrapper.charts.models import ColumnFormat, NumberDivisor

# Using enum (recommended for clarity)
col_format = ColumnFormat(
    column="revenue",
    number_divisor=NumberDivisor.DIVIDE_BY_MILLION,
    number_prepend="$",
    number_append="M"
)

# Using raw int (also valid)
col_format = ColumnFormat(column="revenue", number_divisor=6)

# Using raw string (also valid)
col_format = ColumnFormat(column="revenue", number_divisor="auto")
```

### Line Width and Dash Enums

The `LineWidth` and `LineDash` enums in `models.py` provide developer-friendly ways to specify line styling in LineChart configurations:

**LineWidth Enum Values:**
- `LineWidth.THIN` = "1" - Thin line (1px)
- `LineWidth.MEDIUM` = "2" - Medium line (2px)
- `LineWidth.THICK` = "3" - Thick line (3px)
- `LineWidth.EXTRA_THICK` = "4" - Extra thick line (4px)

**LineDash Enum Values:**
- `LineDash.SOLID` = None - Solid line (no dashes)
- `LineDash.DASHED` = "4,2" - Dashed line pattern
- `LineDash.DOTTED` = "1,2" - Dotted line pattern
- `LineDash.DASH_DOT` = "8,2,1,2" - Dash-dot pattern
- `LineDash.LONG_DASH` = "8,4" - Long dash pattern

**Usage in Line Model:**
The `Line` model (used in LineChart) has `width` and `dash` fields that accept:
- Enum values: `LineWidth.THICK`, `LineDash.DASHED`
- Raw strings: `"3"`, `"4,2"`, `None`

Both fields have validation to ensure only valid values are accepted. Invalid values raise a `ValidationError`.

**Serialization:**
- Enum values are serialized as their string values (e.g., `LineWidth.THICK` becomes `"3"`)
- `LineDash.SOLID` (None) is serialized as `None`
- The API field names are `"width"` and `"dash"`

**Example:**
```python
from datawrapper.charts.models import Line, LineWidth, LineDash

# Using enums (recommended for clarity)
line = Line(
    column="temperature",
    width=LineWidth.THICK,
    dash=LineDash.DASHED,
    color="#FF0000"
)

# Using raw strings (also valid)
line = Line(column="temperature", width="3", dash="4,2")

# Solid line (no dashes)
line = Line(column="temperature", width=LineWidth.MEDIUM, dash=LineDash.SOLID)
```

### Color Category Utility

The `ColorCategory` class in `serializers.py` provides utilities for handling color category mappings:

- `ColorCategory.serialize(color_map, category_labels=None, category_order=None, exclude_from_key=None) -> dict`: Converts Python color mappings to the API's expected format with a `map` key and optional additional fields
- `ColorCategory.deserialize(color_category_obj) -> dict`: Parses the API's color category structure back to Python, returning a dictionary with keys:
  - `color_category`: The color mapping dictionary
  - `category_labels`: Optional labels for categories
  - `category_order`: Optional ordering for categories
  - `exclude_from_color_key`: Optional list of categories to exclude from the legend

This utility is used by AreaChart, BarChart, ColumnChart, LineChart, MultipleColumnChart, StackedBarChart, and ArrowChart to handle the `color-category` field in the visualize metadata.

### Replace Flags Utility

The `ReplaceFlags` class in `serializers.py` provides utilities for handling the replace-flags configuration:

**API Format vs Python Format:**
- **API Format**: Nested object with `{"enabled": bool, "style": str}` (note: uses "style" not "type")
- **Python Format**: Simple string ("off", "4x3", "1x1", "circle")

**Methods:**
- `ReplaceFlags.serialize(flag_type: str) -> dict`: Converts simple string format to API nested object format
  - `"off"` → `{"enabled": False, "style": ""}`
  - `"4x3"` → `{"enabled": True, "style": "4x3"}`
- `ReplaceFlags.deserialize(api_obj: dict | None) -> str`: Converts API nested object format to simple string format
  - `{"enabled": True, "style": "4x3"}` → `"4x3"`
  - `{"enabled": False, "style": ""}` → `"off"`
  - `None` → `"off"`

**Usage:**
This utility is used by BarChart and StackedBarChart to handle the `replace-flags` field, which controls whether country codes are replaced with flag icons in the visualization.

**Important Note:**
The API uses the field name "style" (not "type") in the nested object. This is different from the initial implementation and was corrected based on actual API responses.

**Example:**
```python
from datawrapper.charts.serializers import ReplaceFlags

# Serialization (Python → API)
api_format = ReplaceFlags.serialize("4x3")
# Returns: {"enabled": True, "style": "4x3"}

# Deserialization (API → Python)
python_format = ReplaceFlags.deserialize({"enabled": True, "style": "4x3"})
# Returns: "4x3"
```

### Negative Color Utility

The `NegativeColor` class in `serializers.py` provides utilities for handling negative color configuration:

**API Format vs Python Format:**
- **API Format**: Nested object with `{"enabled": bool, "value": str}` where value is a color hex code
- **Python Format**: Simple string (color hex code like "#ff0000") or None

**Methods:**
- `NegativeColor.serialize(color: str | None) -> dict | None`: Converts simple color string to API nested object format
  - `"#ff0000"` → `{"enabled": True, "value": "#ff0000"}`
  - `None` → `None`
- `NegativeColor.deserialize(api_obj: dict | None) -> str | None`: Converts API nested object format to simple color string
  - `{"enabled": True, "value": "#ff0000"}` → `"#ff0000"`
  - `{"enabled": False, "value": ""}` → `None`
  - `None` → `None`

**Usage:**
This utility is used by ColumnChart, MultipleColumnChart, and StackedBarChart to handle the `negativeColor` field in the visualize metadata. It consolidates what were previously two separate fields (`negative_color_enabled` and `negative_color_value`) into a single, more intuitive field.

**Example:**
```python
from datawrapper.charts.serializers import NegativeColor

# Serialization (Python → API)
api_format = NegativeColor.serialize("#ff0000")
# Returns: {"enabled": True, "value": "#ff0000"}

# Deserialization (API → Python)
python_format = NegativeColor.deserialize({"enabled": True, "value": "#ff0000"})
# Returns: "#ff0000"

# When disabled
python_format = NegativeColor.deserialize({"enabled": False, "value": ""})
# Returns: None
```

### Plot Height Utility

The `PlotHeight` class in `serializers.py` provides utilities for handling chart plot height configuration:

**API Format vs Python Format:**
- **API Format**: Nested object with `{"mode": str, "fixed": int}` where mode can be "fixed" or "ratio"
- **Python Format**: Either an integer (for fixed mode) or a float (for ratio mode)

**Methods:**
- `PlotHeight.serialize(height: int | float) -> dict`: Converts simple numeric format to API nested object format
  - Integer (e.g., `400`) → `{"mode": "fixed", "fixed": 400}`
  - Float (e.g., `0.5`) → `{"mode": "ratio", "fixed": 0.5}`
- `PlotHeight.deserialize(api_obj: dict | None) -> int | float | None`: Converts API nested object format to simple numeric format
  - `{"mode": "fixed", "fixed": 400}` → `400`
  - `{"mode": "ratio", "fixed": 0.5}` → `0.5`
  - `None` → `None`

**Usage:**
This utility is used by LineChart, AreaChart, ColumnChart, MultipleColumnChart, and ScatterPlot to handle the `plot-height` field in the visualize metadata.

**Example:**
```python
from datawrapper.charts.serializers import PlotHeight

# Serialization (Python → API)
api_format = PlotHeight.serialize(400)  # Fixed height
# Returns: {"mode": "fixed", "fixed": 400}

api_format = PlotHeight.serialize(0.5)  # Ratio mode
# Returns: {"mode": "ratio", "fixed": 0.5}

# Deserialization (API → Python)
python_format = PlotHeight.deserialize({"mode": "fixed", "fixed": 400})
# Returns: 400

python_format = PlotHeight.deserialize({"mode": "ratio", "fixed": 0.5})
# Returns: 0.5
```

### Value Labels Utility

The `ValueLabels` class in `serializers.py` provides utilities for handling value label configuration across different chart types:

**Chart Type Variations:**
Different chart types use different API formats for value labels:
- **BarChart**: Flat structure with `show-value-labels` (bool), `value-label-format`, `value-label-alignment`
- **ColumnChart/MultipleColumnChart**: Nested `valueLabels` object with `show`, `format`, `enabled`, `placement`, plus optional top-level `value-label-format` and `value-labels-always` fields
- **LineChart/ArrowChart/StackedBarChart**: Simple `value-label-format` or `value-labels-format` field

**Methods:**
- `ValueLabels.serialize(show, format_str, placement=None, alignment=None, always=None, chart_type="column") -> dict`: Converts Python parameters to API format
  - For column charts: Creates nested `valueLabels` object with optional top-level fields
  - For bar charts: Creates flat structure with alignment
  - For other charts: Creates simple format field
  - The `always` parameter is derived from `show` if not explicitly provided for column charts
  - Only includes `value-labels-always` in output when it's `True`
  - Filters out `None` and empty string values from top-level fields while preserving nested objects

- `ValueLabels.deserialize(api_obj, chart_type="column") -> dict`: Converts API format to Python parameters
  - Parses the appropriate API structure based on chart type
  - For column charts: Extracts from nested `valueLabels` object and derives `value_labels_always` from show mode
  - Returns a dictionary with standardized Python field names

**Usage:**
This utility is used by BarChart, ColumnChart, and MultipleColumnChart to handle value label configuration in the visualize metadata. It consolidates what were previously multiple separate fields into a cleaner, more consistent interface.

**Example (Column Chart):**
```python
from datawrapper.charts.serializers import ValueLabels

# Serialization (Python → API)
api_format = ValueLabels.serialize(
    show="always",
    format_str="0,0",
    placement="outside",
    chart_type="column"
)
# Returns: {
#   "valueLabels": {"show": "always", "format": "0,0", "enabled": True, "placement": "outside"},
#   "value-label-format": "0,0",
#   "value-labels-always": True
# }

# When show is "hover", value-labels-always is excluded
api_format = ValueLabels.serialize(
    show="hover",
    format_str="0,0",
    placement="outside",
    chart_type="column"
)
# Returns: {
#   "valueLabels": {"show": "hover", "format": "0,0", "enabled": True, "placement": "outside"},
#   "value-label-format": "0,0"
# }

# Deserialization (API → Python)
python_format = ValueLabels.deserialize(
    {"valueLabels": {"show": "always", "format": "0,0", "enabled": True, "placement": "outside"}},
    chart_type="column"
)
# Returns: {
#   "show_value_labels": "always",
#   "value_labels_format": "0,0",
#   "value_labels_placement": "outside",
#   "value_labels_always": True
# }
```

**Important Notes:**
- The `always` parameter is automatically derived from `show` if not explicitly provided during serialization for column charts
- The `value-labels-always` field is only included in the API output when it's `True`
- The `enabled` field in the nested `valueLabels` object controls on/off (True for hover or always, False for off)
- The separate `value-labels-always` field controls hover vs always behavior
- This utility standardizes value label handling across different chart types while respecting their unique API requirements
